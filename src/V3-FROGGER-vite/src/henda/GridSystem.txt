import * as THREE from 'three';

export type GridSystemType = {
  gridToWorld(gridX: number, gridZ: number): { x: number; z: number };
  worldToGrid(worldX: number, worldZ: number): { x: number; z: number };
  placeObject(object: THREE.Object3D, gridX: number, gridZ: number): void;
  getObjectInitYPos(objheight: number): number;
  getRandomGridPosition(): { x: number; z: number };
  getRandomHeight(max: number, min: number): number;
  isValidGridPosition(gridX: number, gridZ: number): boolean;
  getGridSize(): number;
  getCellCenter(gridX: number, gridZ: number): { x: number; z: number };
  setBaseHeight(height: number): void;
  getBaseHeight(): number;
  getGridCenter(): { x: number; z: number };
};

/* Grid System used for the X / Z plane */

export class GridSystem {
  private gridSize: number;
  private cellSize: number;
  private offset: number;
  private baseHeight: number; // height of the ground

  constructor(gridSize: number = 15, baseHeight: number = 0) {
    this.gridSize = gridSize;
    this.offset = gridSize / 2; // Offset to center the grid (since Three.js uses center origin)
    this.cellSize = 1; // Default grid-cell size is 1 unit
    this.baseHeight = baseHeight; // Default base height is 0
  }

  // Convert grid coordinates to world coordinates
  gridToWorld(gridX: number, gridZ: number): { x: number; z: number } {
    // For a 15x15 grid:
    // Grid (0,0) → World (-7.5, 7.5)  [bottom left]
    // Grid (14,14) → World (7.5, -7.5) [top right]
    const worldX = (gridX - this.offset + 0.5) * this.cellSize;
    const worldZ = -(gridZ - this.offset + 0.5) * this.cellSize;
    return { x: worldX, z: worldZ }; // new THREE.Vector3(worldX, this.baseHeight, worldZ);
  }

  // Convert world coordinates to grid coordinates
  worldToGrid(worldX: number, worldZ: number): { x: number; z: number } {
    // Convert from world coordinates to grid coordinates
    const gridX = Math.floor(worldX + this.offset);
    const gridZ = Math.floor(-worldZ + this.offset); // 0 is the start / bottom of the grid
    return { x: gridX, z: gridZ };
  }

  // Place an object at a specific grid position
  placeObject(
    object: THREE.Object3D, // | Cannon.Body,
    gridX: number,
    gridZ: number
  ) {
    const worldPos = this.gridToWorld(gridX, gridZ);
    object.position.x = worldPos.x;
    object.position.z = worldPos.z;
  }

  // The Y position for object on ground
  getObjectInitYPos(
    objheight: number,
    baseHeight: number = this.baseHeight
  ): number {
    return baseHeight + objheight / 2;
  }

  // Get random grid position
  getRandomGridPosition(): { x: number; z: number } {
    return {
      x: Math.floor(Math.random() * this.gridSize),
      z: Math.floor(Math.random() * this.gridSize),
    };
  }

  getRandomHeight(max: number, min: number = this.baseHeight): number {
    return Math.floor(Math.random() * (max - min) + min);
  }

  // Check if grid position is within bounds
  isValidGridPosition(gridX: number, gridZ: number): boolean {
    return (
      gridX >= 0 && gridX < this.gridSize && gridZ >= 0 && gridZ < this.gridSize
    );
  }

  // Get the size of the grid
  getGridSize(): number {
    return this.gridSize;
  }

  // Get the center point of a specific grid cell
  getCellCenter(gridX: number, gridZ: number): { x: number; z: number } {
    return this.gridToWorld(gridX, gridZ);
  }

  // Set the base height for all objects
  setBaseHeight(height: number) {
    this.baseHeight = height;
  }

  // Get the current base height
  getBaseHeight(): number {
    return this.baseHeight;
  }

  getGridCenter(): { x: number; z: number } {
    return { x: this.offset, z: this.offset };
  }
}
