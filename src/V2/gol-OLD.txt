import {
  mult,
  translate,
  scalem,
  flatten,
  perspective,
  lookAt,
} from '../lib/MV.js';

import { initShaders } from '../lib/initShaders.js';
import { getGL, getCanvas } from '../lib/init-gl2.js';

import {
  initializeGameState,
  updateGameState,
  gameState,
  activeCellsCount,
} from './game-logic.js';

// Global variables
let gl, program;
let gameState = [];
let activeCellsCount = 0;

// Camera / eye
let camYelevation = 0;
let camRadius = INIT_CAMERA_RADIUS;
let camAngle = 0;
// lookAt parameters
let camPosition = [0, 0, 5];
let camTarget = [0, 0, 0];
let camUpVector = [0, 1, 0];

// WebGL related variables
let points = [];
let colors = [];
let aColor, aPosition, uModelViewLoc, uProjectionLoc;

// Mouse interaction variables
let isDragging = false;
let lastMouseX, lastMouseY;

// const eye = [0, 0, 5];
// const at = [0, 0, 0];
// const up = [0, 1, 0];

// const light = [0.0, 2.0, 0.0];
// let m;

window.onload = function init() {
  setupWebGL();
  createCubeGeometry();
  setupShaders();
  setupEventListeners();
  initializeGameState();
  gameLoop();
};

function setupWebGL() {
  const canvas = getCanvas();
  gl = getGL();
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clearColor(0.0, 0.0, 0.1, 0.1);
  gl.enable(gl.DEPTH_TEST);
}

function createCubeGeometry() {
  const vertices = [
    [-0.5, -0.5, 0.5],
    [-0.5, 0.5, 0.5],
    [0.5, 0.5, 0.5],
    [0.5, -0.5, 0.5],
    [-0.5, -0.5, -0.5],
    [-0.5, 0.5, -0.5],
    [0.5, 0.5, -0.5],
    [0.5, -0.5, -0.5],
  ];
  const vertexColors = [
    [0.0, 0.0, 0.0, 1.0],
    [1.0, 0.0, 0.0, 1.0],
    [1.0, 1.0, 0.0, 1.0],
    [0.0, 1.0, 0.0, 1.0],
    [0.0, 0.0, 1.0, 1.0],
    [1.0, 0.0, 1.0, 1.0],
    [0.0, 1.0, 1.0, 1.0],
    [1.0, 1.0, 1.0, 1.0],
  ];
  const faces = [
    [1, 0, 3, 2],
    [2, 3, 7, 6],
    [3, 0, 4, 7],
    [6, 5, 1, 2],
    [4, 5, 6, 7],
    [5, 4, 0, 1],
  ];

  faces.forEach((face) => {
    const [a, b, c, d] = face;
    const indices = [a, b, c, a, c, d];
    indices.forEach((i) => {
      points.push(vertices[i]);
      colors.push(vertexColors[a]);
    });
  });
}

function setupShaders() {
  program = initShaders(gl, 'vertex-shader', 'fragment-shader');
  gl.useProgram(program);

  // Set up attribute and uniform locations
  aColor = gl.getAttribLocation(program, 'aColor');
  aPosition = gl.getAttribLocation(program, 'aPosition');
  uModelViewLoc = gl.getUniformLocation(program, 'uModelView');
  uProjectionLoc = gl.getUniformLocation(program, 'uProjection');

  // Create and bind buffers
  createBuffer(gl.ARRAY_BUFFER, new Float32Array(flatten(colors)), aColor, 4);
  createBuffer(
    gl.ARRAY_BUFFER,
    new Float32Array(flatten(points)),
    aPosition,
    3
  );

  // Set up projection matrix
  const aspect = gl.canvas.width / gl.canvas.height;
  const projectionMatrix = perspective(
    FIELD_OF_VIEW,
    aspect,
    NEAR_PLANE,
    FAR_PLANE
  );
  gl.uniformMatrix4fv(uProjectionLoc, false, flatten(projectionMatrix));
}

function createBuffer(type, data, attribute, size) {
  const buffer = gl.createBuffer();
  gl.bindBuffer(type, buffer);
  gl.bufferData(type, data, gl.STATIC_DRAW);
  gl.vertexAttribPointer(attribute, size, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(attribute);
}

function setupEventListeners() {
  gl.canvas.addEventListener('mousedown', handleMouseDown);
  gl.canvas.addEventListener('mouseup', handleMouseUp);
  gl.canvas.addEventListener('mousemove', handleMouseMove);
  gl.canvas.addEventListener('wheel', handleWheel);
  window.addEventListener('keydown', handleKeyDown);
}

function initializeGameState() {
  gameState = Array(GRID_SIZE)
    .fill()
    .map(() =>
      Array(GRID_SIZE)
        .fill()
        .map(() =>
          Array(GRID_SIZE)
            .fill()
            .map(() => (Math.random() < 0.25 ? 1 : 0))
        )
    );
  activeCellsCount = gameState.flat(3).filter((cell) => cell === 1).length;
  console.log('Initial active cells:', activeCellsCount);
}

function gameLoop() {
  updateGameState();
  render();
  setTimeout(gameLoop, 750);
}

function updateGameState() {
  const newState = JSON.parse(JSON.stringify(gameState));
  let newActiveCellsCount = 0;

  for (let x = 0; x < GRID_SIZE; x++) {
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let z = 0; z < GRID_SIZE; z++) {
        const neighbors = countNeighbors(x, y, z);
        if (gameState[x][y][z] === 1) {
          if (neighbors < 5 || neighbors > 7) {
            newState[x][y][z] = 0;
          } else {
            newActiveCellsCount++;
          }
        } else {
          if (neighbors === 6) {
            newState[x][y][z] = 1;
            newActiveCellsCount++;
          }
        }
      }
    }
  }

  gameState = newState;
  activeCellsCount = newActiveCellsCount;
  console.log('Active cubes:', activeCellsCount);
}

function countNeighbors(x, y, z) {
  let count = 0;
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      for (let dz = -1; dz <= 1; dz++) {
        if (dx === 0 && dy === 0 && dz === 0) continue;
        const nx = (x + dx + GRID_SIZE) % GRID_SIZE;
        const ny = (y + dy + GRID_SIZE) % GRID_SIZE;
        const nz = (z + dz + GRID_SIZE) % GRID_SIZE;
        count += gameState[nx][ny][nz];
      }
    }
  }
  return count;
}

function render() {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  updateCameraPosition();
  const modelViewMatrix = lookAt(camPosition, camTarget, camUpVector);

  const scaleFactor = calculateScaleFactor();
  const gridSizeScale = calculateGridSizeScale();

  for (let x = 0; x < GRID_SIZE; x++) {
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let z = 0; z < GRID_SIZE; z++) {
        if (gameState[x][y][z] === 1) {
          renderCube(x, y, z, modelViewMatrix, scaleFactor, gridSizeScale);
        }
      }
    }
  }

  requestAnimationFrame(render);
}

function updateCameraPosition() {
  const theta = camAngle;
  const phi = camYelevation;
  camPosition[0] = camRadius * Math.cos(phi) * Math.sin(theta);
  camPosition[1] = camRadius * Math.sin(phi);
  camPosition[2] = camRadius * Math.cos(phi) * Math.cos(theta);
}

function calculateScaleFactor() {
  const maxCubeScale = 3;
  const minCubeScale = 0.5;
  return (
    minCubeScale + (maxCubeScale - minCubeScale) * (activeCellsCount / 300)
  );
}

function calculateGridSizeScale() {
  const maxGridSize = 3;
  const minGridSize = 0.05;
  return minGridSize + (maxGridSize - minGridSize) * (activeCellsCount / 300);
}

function renderCube(x, y, z, modelViewMatrix, scaleFactor, gridSizeScale) {
  let cellModelView = mult(
    modelViewMatrix,
    translate(
      (x - GRID_SIZE / 2 + 0.5) * gridSizeScale,
      (y - GRID_SIZE / 2 + 0.5) * gridSizeScale,
      (z - GRID_SIZE / 2 + 0.5) * gridSizeScale
    )
  );
  cellModelView = mult(
    cellModelView,
    scalem(scaleFactor, scaleFactor, scaleFactor)
  );
  gl.uniformMatrix4fv(uModelViewLoc, false, flatten(cellModelView));
  gl.drawArrays(gl.TRIANGLES, 0, 36);
}

// Event handlers
function handleMouseDown(event) {
  isDragging = true;
  lastMouseX = event.offsetX;
  lastMouseY = event.offsetY;
}

function handleMouseUp() {
  isDragging = false;
}

function handleMouseMove(event) {
  if (isDragging) {
    const dx = event.offsetX - lastMouseX;
    const dy = event.offsetY - lastMouseY;

    camAngle += dx * 0.01;
    camYelevation = Math.max(
      -Math.PI / 2,
      Math.min(Math.PI / 2, camYelevation - dy * 0.01)
    );

    lastMouseX = event.offsetX;
    lastMouseY = event.offsetY;
  }
}

function handleWheel(event) {
  event.preventDefault();
  camRadius = Math.max(1, Math.min(100, camRadius + event.deltaY * 0.01));
}

function handleKeyDown(event) {
  const KEY_STEP = 0.1;
  switch (event.key.toLowerCase()) {
    case 'a':
      camAngle -= KEY_STEP;
      break;
    case 'd':
      camAngle += KEY_STEP;
      break;
    case 'w':
      camYelevation = Math.min(camYelevation + KEY_STEP, Math.PI / 2);
      break;
    case 's':
      camYelevation = Math.max(camYelevation - KEY_STEP, -Math.PI / 2);
      break;
  }
}

// Export variables that might be needed in other modules
export {
  gl,
  program,
  camYelevation,
  camRadius,
  camAngle,
  camPosition,
  camTarget,
  camUpVector,
  points,
  colors,
  aColor,
  aPosition,
  uModelViewLoc,
  uProjectionLoc,
};
