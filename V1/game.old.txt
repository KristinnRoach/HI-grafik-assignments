import { showError } from '../../lib/error.js';
import { getGL, getCanvas } from '../../lib/init-gl2.js';
import { initShaders } from '../../lib/initShaders.js';

/** @type {HTMLCanvasElement|null} */
const canvas = getCanvas();

/** @type {WebGL2RenderingContext} */
const gl = getGL();

let vPosLocation;

let gun;
let bird;
let bullets = [];

let gameOver = false;
let score = 0;

function updateGame() {
  // Update bird position
  bird.x += bird.speed;
  if (bird.x > 1) bird.x = -1;

  // Update bullets
  bullets = bullets.filter((b) => {
    b.y += b.speed;
    return b.y <= 1; // Keep bullets that are still on screen
  });

  // Check for collisions
  bullets.forEach((b) => {
    if (checkCollision(bird, b)) {
      handleCollision(b);
    }
  });

  updateBuffers();
}

function checkCollision(bird, bullet) {
  // Assuming bird and bullet have properties: x, y, width, height
  return (
    bird.x < bullet.x + bullet.width &&
    bird.x + bird.width > bullet.x &&
    bird.y < bullet.y + bullet.height &&
    bird.y + bird.height > bullet.y
  );
}

function handleCollision(collidedBullet) {
  bullets = bullets.filter((b) => b !== collidedBullet);
  bird.x = -1; // Reset bird position
  score++;
}

function createBullet() {
  const bullet = {
    x: gun.x,
    y: gun.y,
    width: 0.01,
    height: 0.01,
    speed: 0.01,
    buffer: gl.createBuffer(),
  };

  const bulletVertices = new Float32Array([
    bullet.x,
    bullet.y,
    bullet.x + bullet.width,
    bullet.y,
    bullet.x,
    bullet.y - bullet.height,
    bullet.x + bullet.width,
    bullet.y - bullet.height,
  ]);
  gl.bindBuffer(gl.ARRAY_BUFFER, bullet.buffer);
  gl.bufferData(gl.ARRAY_BUFFER, bulletVertices, gl.DYNAMIC_DRAW);

  bullets.push(bullet);
}

function updateBuffers() {
  // Update bird buffer
  const birdVertices = new Float32Array([
    bird.x,
    bird.y,
    bird.x + bird.width,
    bird.y,
    bird.x,
    bird.y - bird.height,
    bird.x + bird.width,
    bird.y - bird.height,
  ]);
  gl.bindBuffer(gl.ARRAY_BUFFER, bird.buffer);
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, birdVertices);

  // Update all bullet buffers
  bullets.forEach((b) => {
    const bulletVertices = new Float32Array([
      b.x,
      b.y,
      b.x + b.width,
      b.y,
      b.x,
      b.y - b.height,
      b.x + b.width,
      b.y - b.height,
    ]);
    gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, bulletVertices);
  });

  // Update gun buffer
  const gunVertices = new Float32Array([
    gun.x,
    gun.y,
    gun.x - gun.width / 2,
    gun.y - gun.height,
    gun.x + gun.width / 2,
    gun.y - gun.height,
  ]);
  gl.bindBuffer(gl.ARRAY_BUFFER, gun.buffer);
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, gunVertices);
}

function render() {
  gl.clearColor(0.8, 0.8, 0.8, 1.0); // Light gray background

  gl.clear(gl.COLOR_BUFFER_BIT);

  // Draw bird
  gl.bindBuffer(gl.ARRAY_BUFFER, bird.buffer);
  gl.vertexAttribPointer(vPosLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(vPosLocation);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  // Draw all bullets
  bullets.forEach((b) => {
    gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
    gl.vertexAttribPointer(vPosLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(vPosLocation);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  });

  // Draw gun
  gl.bindBuffer(gl.ARRAY_BUFFER, gun.buffer);
  gl.vertexAttribPointer(vPosLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(vPosLocation);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
}

function gameLoop() {
  if (!gameOver) {
    updateGame();
    render();
    requestAnimationFrame(gameLoop);
  } else {
    console.log(`Game over! Score: ${score}`);
  }
}

function initGameObjects() {
  gun = {
    buffer: null,
    x: 0, // Center screen
    y: -0.9, // Bottom of screen
    width: 0.1,
    height: 0.1,
  };

  bird = {
    buffer: null,
    x: -1, // Start off-screen to the left
    y: 0.7, //
    width: 0.1,
    height: 0.05,
    speed: 0.005, // How fast the bird moves each frame
  };
}

function initBuffers() {
  // Gun (triangle)
  const gunVertices = new Float32Array([
    gun.x,
    gun.y,
    gun.x - gun.width / 2,
    gun.y - gun.height,
    gun.x + gun.width / 2,
    gun.y - gun.height,
  ]);
  gun.buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, gun.buffer);
  gl.bufferData(gl.ARRAY_BUFFER, gunVertices, gl.DYNAMIC_DRAW);

  // Bird (rectangle)
  const birdVertices = new Float32Array([
    bird.x,
    bird.y,
    bird.x + bird.width,
    bird.y,
    bird.x,
    bird.y - bird.height,
    bird.x + bird.width,
    bird.y - bird.height,
  ]);
  bird.buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bird.buffer);
  gl.bufferData(gl.ARRAY_BUFFER, birdVertices, gl.DYNAMIC_DRAW);
}

function init() {
  try {
    const program = initShaders(gl, 'vertex-shader', 'fragment-shader');
    gl.useProgram(program);

    vPosLocation = gl.getAttribLocation(program, 'vPos');
    if (vPosLocation < 0) {
      throw new Error('Failed to get attribute location for vPos');
    }

    initGameObjects();
    initBuffers();

    // Enable the attribute array
    gl.enableVertexAttribArray(vPosLocation);

    gameLoop();
  } catch (e) {
    showError(`Initialization error: ${e}`);
  }
}

window.onload = init;

let lastShotTime = 0;
const shootCooldown = 50; // milliseconds

document.addEventListener('keydown', (event) => {
  if (event.key === 'ArrowLeft' || event.key === 'a') {
    gun.x = Math.max(gun.x - 0.1, -1);
  } else if (event.key === 'ArrowRight' || event.key === 'd') {
    gun.x = Math.min(gun.x + 0.1, 1);
  } else if (
    event.key === ' ' ||
    event.key === 'ArrowUp' ||
    event.key === 'w'
  ) {
    const currentTime = Date.now();
    if (currentTime - lastShotTime < shootCooldown) return;
    createBullet();
    lastShotTime = currentTime;
  }
});

document.addEventListener('mousedown', () => {
  const currentTime = Date.now();
  if (currentTime - lastShotTime < shootCooldown) return;
  createBullet();
  lastShotTime = currentTime;
});
